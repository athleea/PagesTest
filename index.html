<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Ï∞®Îüâ ÌÉëÏäπÏûê Ï†ïÌïòÍ∏∞</title>
  <style>
    /* CSS remains unchanged */
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background-color: #E0F7FA;
      margin: 0;
      padding: 20px;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
    }

    h1 {
      color: black;
      text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
      font-size: 1.5em;
    }

    #form {
      background: white;
      padding: 15px;
      border-radius: 12px;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
      width: 90%;
      max-width: 800px;
      margin-bottom: 20px;
      border: 1px solid #29ABE2;
    }

    textarea,
    button {
      width: 100%;
      padding: 8px;
      margin: 8px 0;
      border-radius: 6px;
      font-size: 14px;
      box-sizing: border-box;
    }

    textarea {
      background-color: #f0f8ff;
      color: #333;
      border: 1px solid #29ABE2;
    }

    button {
      background-color: #29ABE2;
      color: white;
      border: none;
      font-weight: bold;
      cursor: pointer;
      transition: background-color 0.3s ease;
    }

    button:hover {
      background-color: #2391c4;
    }

    .canvas-wrapper {
      display: flex;
      justify-content: center;
      width: 100%;
      max-width: 1400px;
    }

    canvas {
      background: white;
      border-radius: 10px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
      width: 100%;
      height: auto;
      max-width: 100%;
      border: 1px solid #29ABE2;
    }

    #summary {
      font-size: 14px;
      color: #333;
      margin-bottom: 10px;
    }

    #error-log {
      color: red;
      font-size: 12px;
      margin-top: 10px;
    }

    @media (max-width: 600px) {
      body { padding: 10px; }
      h1 { font-size: 1.2em; }
      #form { padding: 10px; }
      textarea,
      button { font-size: 12px; padding: 6px; }
      #summary { font-size: 12px; }
    }
  </style>
</head>

<body>
  <h1>Ï∞®Îüâ ÌÉëÏäπÏûê Ï†ïÌïòÍ∏∞</h1>
  <div id="form">
    <textarea id="allPeopleInput" rows="7" oninput="updateSummary()">Bert  
Bob  
Chole  
Charlie  
Eddy  
Edan  
Harry  
Han  
Hyde  
Jack  
Jackey  
Jason  
Jay  
Junny  
Kevin  
Luna  
Michael  
Luke  
Russell  
Sub  
Tony  
Will  
Xia</textarea>
    <h3>üöó Ïö¥Ï†ÑÏûê Î∞è ÌÉëÏäπ Í∞ÄÎä• Ïàò ÏûÖÎ†•</h3>
    <textarea id="driversInput" rows="7" oninput="updateSummary()">Bert,3
Jason,3
Bob,3
Luke,3
Charlie,3
Michael,3
Harry,3</textarea>
    <div id="summary"></div>
    <div id="error-log"></div>
    <button onclick="startSimulation()">üéÆ</button>
  </div>

  <div class="canvas-wrapper">
    <canvas id="canvas"></canvas>
  </div>

  <script>
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    const COLORS = [
		"#FFD700", // Gold
		"#87CEFA", // Sky Blue
		"#FFB6C1", // Light Pink
		"#98FB98", // Pale Green
		"#FFA07A", // Light Salmon
		"#DA70D6", // Orchid
		"#FF4500", // Orange Red
		"#00CED1", // Dark Turquoise
		"#FF69B4", // Hot Pink
		"#7FFF00"  // Chartreuse
	];
    const DRIVER_COLORS = COLORS
    
    let cars = [];
    let balls = [];
    let maxAssignedPerCar = 4;
    let BASE_IMAGE_SIZE = 0;
    const imageCache = new Map();
    const driverColorMap = new Map();
    const defaultImage = new Image();
    defaultImage.src = "images/default.png";
    const errorLog = document.getElementById("error-log");

    // Ïú†Ìã∏Î¶¨Ìã∞ Ìï®Ïàò
    const getResponsiveImageSize = () => Math.max(60, Math.min(100, document.querySelector(".canvas-wrapper").clientWidth / 8));
    const getColorByName = name => COLORS[name.split('').reduce((hash, char) => char.charCodeAt(0) + ((hash << 5) - hash), 0) % COLORS.length];
    const getDriverColor = name => driverColorMap.get(name) || (driverColorMap.set(name, DRIVER_COLORS[driverColorMap.size % DRIVER_COLORS.length]).get(name));
    const shuffleArray = array => array.sort(() => Math.random() - 0.5);

    const logError = message => {
      errorLog.textContent += `${message}\n`;
      console.error(message);
    };

    const loadImage = name => imageCache.get(name) || (imageCache.set(name, new Promise(resolve => {
      const img = new Image();
      img.src = `images/${name}.png`;
      img.onload = () => resolve(img);
      img.onerror = () => {
        logError(`Failed to load image: images/${name}.png`);
        resolve(defaultImage);
      };
    })), imageCache.get(name));

    const resizeCanvas = () => {
      const wrapper = document.querySelector(".canvas-wrapper");
      canvas.width = Math.min(1400, wrapper.clientWidth);
      BASE_IMAGE_SIZE = getResponsiveImageSize();
      canvas.height = (maxAssignedPerCar + 1) * BASE_IMAGE_SIZE + 300;
      canvas.style.height = `${canvas.height}px`;
    };

    class Ball {
      constructor(name, x, y, targetX, targetY, image, color) {
        this.name = name;
        this.x = x;
        this.y = y;
        this.targetX = targetX;
        this.targetY = targetY;
        this.image = image;
        this.color = color;
        this.radius = BASE_IMAGE_SIZE / 2;
        this.t = 0;
        this.duration = 200 + Math.random() * 200;
        this.startAngle = Math.random() * Math.PI * 2;
        this.scale = 0.5;
        this.opacity = 0;
      }

      update() {
        if (this.t < this.duration) {
          const t = this.t++ / this.duration;
          const easedT = 1 - (1 - t) ** 4;
          const spiralRadius = (1 - easedT) * BASE_IMAGE_SIZE;
          this.scale = 0.5 + easedT * 0.5;
          this.opacity = easedT;
          this.draw(
            this.x + Math.cos(this.startAngle + easedT * Math.PI * 2) * spiralRadius + (this.targetX - this.x) * easedT,
            this.y + Math.sin(this.startAngle + easedT * Math.PI * 2) * spiralRadius + (this.targetY - this.y) * easedT
          );
        } else {
          this.scale = this.opacity = 1;
          this.draw(this.targetX, this.targetY);
        }
      }

      draw(x, y) {
        ctx.save();
        ctx.globalAlpha = this.opacity;
        const scaledSize = this.radius * 2 * this.scale;
        ctx.beginPath();
        ctx.arc(x, y, this.radius * this.scale, 0, Math.PI * 2);
        ctx.fillStyle = this.color;
        ctx.fill();
        if (this.image) ctx.drawImage(this.image, x - this.radius * this.scale, y - this.radius * this.scale, scaledSize, scaledSize);
        ctx.fillStyle = "#000";
        ctx.font = `bold ${BASE_IMAGE_SIZE / 8 * this.scale}px sans-serif`;
        ctx.textAlign = "center";
        ctx.fillText(this.name, x, y + this.radius * this.scale + BASE_IMAGE_SIZE / 8 * this.scale);
        ctx.restore();
      }
    }

    const updatePositions = () => {
      const spacing = Math.min(BASE_IMAGE_SIZE * 2.2, (canvas.width - BASE_IMAGE_SIZE) / cars.length);
      const offsetX = (canvas.width - (cars.length - 1) * spacing) / 2;
      const verticalSpacing = BASE_IMAGE_SIZE * 1.125 + 10;

      cars.forEach((car, i) => {
        car.x = offsetX + i * spacing;
        car.y = canvas.height - BASE_IMAGE_SIZE * 2;
      });

      balls.forEach(ball => {
        const car = cars.find(c => c.assigned.includes(ball.name));
        if (car) {
          const index = car.assigned.indexOf(ball.name);
          ball.targetX = car.x;
          ball.targetY = car.y - 30 - BASE_IMAGE_SIZE - index * verticalSpacing;
        }
      });
    };

    const startSimulation = async () => {
      errorLog.textContent = ''; // Clear previous errors
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      const allPeople = document.getElementById("allPeopleInput").value.trim().split("\n").map(p => p.trim()).filter(Boolean);
      const driverLines = document.getElementById("driversInput").value.trim().split("\n").map(l => l.trim()).filter(Boolean);

      if (!allPeople.length || !driverLines.length) {
        logError("Error: No people or drivers provided.");
        return;
      }

      cars = await Promise.all(driverLines.map(async line => {
        const [name, seats] = line.split(",");
        if (!name || !seats || isNaN(seats)) {
          logError(`Invalid driver input: ${line}`);
          return null;
        }
        return {
          driver: name.trim(),
          capacity: parseInt(seats),
          assigned: [],
          x: 0,
          y: 0,
          image: await loadImage(name.trim()),
          color: getDriverColor(name.trim())
        };
      })).then(results => results.filter(Boolean));

      if (!cars.length) {
        logError("Error: No valid drivers found.");
        return;
      }

      const driverNames = cars.map(car => car.driver);
      let passengers = shuffleArray(allPeople.filter(name => !driverNames.includes(name)));
      cars = shuffleArray(cars);
      maxAssignedPerCar = 4;
      balls = [];

      for (const [i, passenger] of passengers.entries()) {
        const available = cars.filter(car => car.assigned.length < car.capacity);
        if (!available.length) {
          logError(`No available seats for passenger: ${passenger}`);
          continue;
        }
        const car = available.reduce((min, curr) => curr.assigned.length < min.assigned.length ? curr : min);
        car.assigned.push(passenger);
        maxAssignedPerCar = Math.max(maxAssignedPerCar, car.assigned.length);
        balls.push(new Ball(
          passenger,
          BASE_IMAGE_SIZE / 2 + i * BASE_IMAGE_SIZE * 0.3,
          30,
          car.x,
          car.y - 30 - BASE_IMAGE_SIZE - car.assigned.length * (BASE_IMAGE_SIZE * 1.125 + 10),
          await loadImage(passenger),
          car.color
        ));
      }

      resizeCanvas();
      updatePositions();
    };

    const animate = () => {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      cars.forEach(car => {
        const radius = BASE_IMAGE_SIZE / 2;
        ctx.beginPath();
        ctx.arc(car.x, car.y, radius, 0, Math.PI * 2);
        ctx.fillStyle = car.color;
        ctx.fill();
        if (car.image) ctx.drawImage(car.image, car.x - radius, car.y - radius, radius * 2, radius * 2);
        ctx.fillStyle = "#000";
        ctx.font = `bold ${BASE_IMAGE_SIZE / 8}px sans-serif`;
        ctx.textAlign = "center";
        ctx.fillText(car.driver, car.x, car.y + radius + BASE_IMAGE_SIZE / 8);
        ctx.fillStyle = "#333";
        ctx.font = `${BASE_IMAGE_SIZE / 10}px sans-serif`;
        ctx.fillText(`(${car.assigned.length}/${car.capacity})`, car.x, car.y + radius + BASE_IMAGE_SIZE / 4);
        if (car.assigned.length) {
          ctx.fillStyle = "#555";
          ctx.font = `bold ${BASE_IMAGE_SIZE / 10}px sans-serif`;
          ctx.fillText(car.assigned.join(", "), car.x, car.y + radius + BASE_IMAGE_SIZE / 2.5);
        }
      });

      balls.forEach(ball => ball.update());
      requestAnimationFrame(animate);
    };

    const updateSummary = () => {
      const allPeople = document.getElementById("allPeopleInput").value.trim().split("\n").map(p => p.trim()).filter(Boolean);
      const driverLines = document.getElementById("driversInput").value.trim().split("\n").map(l => l.trim()).filter(Boolean);
      const driverNames = driverLines.map(([name]) => name?.trim()).filter(Boolean);
      const totalSeats = driverLines.reduce((sum, [, seats]) => sum + (parseInt(seats) || 0), 0);
      const passengerCount = allPeople.length - driverNames.length;

      document.getElementById("summary").textContent =
        `Ï¥ù Ïù∏Ïõê: ${allPeople.length}Î™Ö | Ïö¥Ï†ÑÏûê: ${driverNames.length}Î™Ö | ÌÉëÏäπÏûê: ${passengerCount}Î™Ö | Ï¥ù Ï¢åÏÑù Ïàò: ${totalSeats}ÏÑù`;
    };

    window.addEventListener("load", () => {
      resizeCanvas();
      updateSummary();
      animate();
    });

    window.addEventListener("resize", () => {
      resizeCanvas();
      updatePositions();
    });
  </script>
</body>
</html>